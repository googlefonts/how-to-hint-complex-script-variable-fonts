# A guide to hinting complex script Variable Fonts with Visual TrueType

by [Michael Duggan](https://twitter.com/mickduggan)

## Hinting complex script Variable fonts in VTT (Visual TrueType) 

**Note:** This document is a companion piece to the longer [Hinting Latin TrueType Variable Fonts with Visual TrueType](https://github.com/googlefonts/how-to-hint-variable-fonts#introduction) 

*Please refer first to this comprehensive documentation for all of the details of the workflow, detailed descriptions of the hinting code, and how to use the VTT Tool to add hinting to Variable Fonts..*  

**Notes on running the VTT Autohinter for complex script Variable Fonts**

Before beginning any new Hinting project, it is important to understand the options and requirements for running the VTT Autohinter for complex script Variable fonts. The Visual TrueType tool has the following options for Autohinting.

**(1) Light Latin Autohinter:** Designed to work for Latin fonts, including Greek and Cyrillic. This option can also be used to add hinting to complex script fonts. **Note:** To run the VTT Light Latin Autohinter, for complex script fonts, VTT requires that the font must contain at least the Latin Ascii glyph set. If there is no Latin Ascii glyph set, the Light Latin Autohinter will not run, and will return an error message. (Unicode 0x48 (H) is missing in this font). 

If your font contains a Latin and a complex script glyph set, the Latin portion of the font will be auto-hinted, with cvt’s generated for key Heights. The Autohinter will add hinting code to the complex script glyph set, but will not generate cvt’s for any heights. Although the VTT Autohinter does not add cvt information for heights for complex script glyph sets, it is worthwhile running it, to begin any hinting project. In addition to adding basic hinting code, VTT also generates a full Font-Program and Pre-Program as well as code for any composites in the font. This saves a lot of time versus building this information from scratch. The basic hinting code that is added to the individual complex script glyphs can also be a good starting point to build from. We will look at this in more detail in the examples of hinting later in the Document.

**(2) EA Autohinter:** If a font does not contain a Latin subset, or you do not wish to add these glyphs you can run the VTT East Asian Autohinter. Using this option VTT will autohint a font without the requirement to add a Latin glyph set. If the hinting strategy used by the East Asian Autohinter is appropriate for you font, you can proceed from here using the code generated by the EA Autohinter. This will also include all of the necessary tables, Font-Program and Pre-Program. This Autohinter makes use of a lightweight hinting strategy that focuses on the horizontal strokes common in East Asian scripts. The strategy, takes advantage of Windows symmetric rendering modes and locks one side of horizontal strokes to the pixel grid while letting the top of other side float. This strategy balances edge contrast vs. blur and produces a good distribution of strokes with balanced counters. The Autohinting code output, should be reviewed and the font proofed carefully, to ensure this approach is suitable for your font. 

**(3) Control program only:** This option is similar to number 1 above, and has the same requirements for the inclusion of Latin glyph set. Using the control program only Autohinting option, is used when the intent is to add hinting to the font from scratch, via the graphical hinting interface or by writing the High Level VTT Talk by hand. The Control Program option will generate, a simple CVT Table, Font Program and will generate glyph program code for composite glyphs. Hinting code for the unique glyphs in the font will not be added. 

## Introduction

When thinking about adding hinting to any Variable font, it is a good idea to ask a few questions first. How does hinting work in modern environments? What value can hinting add? Is hinting suitable for my font? The first two questions are answered in the longer VTT Variable font Hinting document, referenced at the beginning, which gives an overview of the current rendering technologies and the main benefits of modern hinting, with a focus on Variable Font Hinting. The third question can be answered by a series of tests and proofing in VTT. 

As an example of Hinting complex script Variable fonts, we will be looking at adding and fine tuning hinting for some key representative glyphs in the Noto Devanagari Serif Variable font. The workflow and concepts discussed for the Devanagari font, can be used for other complex script Variable fonts. 

**Is hinting suitable for my font?**
Once you know more about what hinting is capable of, you can then ask a few questions about the font itself. Is the font intended for reading at smaller sizes or is it primarily a Display font, intended for use at larger sizes? If the latter, is hinting really needed? What benefits can I expect by adding hinting? How complex are the outline shapes? Many complex scripts fonts can benefit from hinting particularly at smaller sizes. For some scripts, such as Chinese, Japanese and Korean for example, the complexity of the outlines makes it impossible to apply hints that will benefit smaller sizes. Once there are enought pixels at larger sizes, hinting can help to sharpen common horizontal strokes and reduce blur. Every font should be evaluated to begin with to determine the most appropriate hinting stragety. 

We will look at these questions as we progress through this document, and will also look at the different approaches to hinting individual glyphs, and some of the limitations of Hinting Variable fonts in VTT.

## Case Study: Hinting Noto Devanagari Serif Variable font

For the remainer of this document we will look at adding hinting to the Noto Serif Devanagari Variable font. All of the processes and workflow can be followed and adapted for other complex script Variable fonts. A good way to begin, to evaluate the overall effects of hinting, is to run the VTT Autohinter, and review the output.

**Determining benefits of Hinting by running the Autohinter**

Sharpenening of horizontal strokes at smaller screen sizes on lower resolution screens is one of the main effects of modern hinting. This sharpening significantly reduces blur along key horizontal strokes, producing much sharper text at smaller sizes. 

Running the VTT Autohinter and quickly reviewing the results will give you a good impression of the big picture of how hinting will help to render the font at small screen sizes particularly in relation to the key horizontals in the Devanagari font design. By evaluating the initial results produced by the Autohinter, you can determine the benefits of hinting and then build on refining the hinting code. 

<img width="100%" height="100%" src="Images/BlurvSharp.png">

**Left** Horizonal stroke un-hinted. After the un-hinted outline is scaled and rendered at a particular size, the result is very often a blurred line.
**Right** Horizonal stroke hinted. The Autohinter uses a stragety to move the outline to a high contrast grid boundary.

Following on from this basic idea, we can now see how this hinting effect, improves the rendering overall for many of the main Devanagari glyphs.

<img width="100%" height="100%" src="Images/DevanagariBlurSharp.png">

**Key Horizonal sharpening** Hinting results in sharpening of main Horizontal stokes, along the key Headline alignment zone, shown here using representative Devanagari glyphs at 9 and 12 point @96dpi


<img width="100%" height="100%" src="Images/WeightBlurSharp.png">

**Improvements across Variation space** One set of of hinting code is applied to all weight variations in the Variable font, resulting in sharpening of main Horizontal stokes for all weights. 

## Alignments and measurements

<img width="100%" height="100%" src="Images/HeightsDevanagari.png">

**Top:** Key heights are determined by referencing some representative glyphs in the Noto Devanagari Variable font. The measurements taken from these glyphs, will be used to set up new cvt's that be referenced in the hinting code.

Referencing ‘cvt’ values from hinting instructions in a set of glyphs that share similar measurements in the Devanagari font allows strict control over the regularity of these features. For the hinting described here, new cvt’s will be used to ensure key heights are kept consistent at any given point size. When adding hints, an ‘anchor’, _(such as is added by the Autohinter)_ on any point, will be rounded to the nearest grid line. However, a YAnchor, _for example,_ can refer to a ‘cvt’ value to specify a height or overshoot shared by other glyphs in the font. Instead of rounding to the nearest grid line, the anchored point will round to the grid line specified by the ‘cvt’ value. 

This is also useful for making global adjustments to heights, and proportions for a range of glyphs, by adjusting just one cvt. Global adjustments to proportions in complex script fonts, can help provide more space for Bolder weights, for example, helping to make the rendering much clearer on-screen.
 
## Adding new CVT's for Devanagari 

Now that we have taken some measurements from the font outlines, we can build some new cvt’s for use in hinting the Devanagari. The illustration above shows four key measurements taken from representatinve glyphs. We can add futher cvt’s when required, for any other aligment zones, that can be determined in the font.

To add the new cvt’s, open the Control program, and add the following cvt entries, starting with the next available ID number, in this case cvt number 167. _(Because this font contains a Latin Subset, the Autohinter has already generated cvt’s for the Latin font)_

Add four new cvt’s, for ‘Main Headline Height’, ‘Headline overshoot’, ‘Baseline’, and ‘Baseline undershoot’ using the measurements taken from the outlines. Compile and Save the Control Program. These new cvt's are now available for use, and can be referenced in the VTTTalk Hinting code. 

/***** Devanagari Height cvt’s *****/
 
      167:   623 /* Main Flat Headline height */
  
ASM("SVTCA[Y]")
ASM("CALL[], 167, 89")
 
      169:     0 /* baseline */
ASM("SVTCA[Y]")
ASM("CALL[], 169, 89")
  RoundHeight
      168:    5 ~   167 @ 42 /* cap height overshoot */
      170:   -5 ~   169 @ 42 /* baseline undershoot */
 


## Hinting Devanagari letter GA (Unicode+0917)

Let’s begin by looking at how to add hinting to Devanagari letter GA. In this example we will delete the existing Autohinting code and add the hinting via the graphical user interface. The main height controls and cvt’s added to this glyph will set the direction for adding hinting and maintaining consistent height control for other Devanagari glyphs, that share the same headline and baseline heights.

**Hinting strategy**

1. Control the y-max (Headline) and y-min of the glyph (Baseline / baseline undershoot) to be consistent with other glyphs that share the same alignment, using values in the Control Value Table as a reference. Minimise blur at the ‘Headline’.

2. Control the position of the middle element, in relation to the Baseline and Headline. 

![LatinAutohinter](Images/HintDevanagariOne.gif)

**Hinting the GA **

**Step 1: Devanagari Headline Height Control** 

Choose the Yshift Tool from the Toolbar. Position the ‘blue circle’, directly over point 28, click, and drag to point 26 and release. 

The following code is generated in the VTT Talk Window.

**YAnchor (28)** Moves point 28 to the nearest gridline. The appropriate cvt for the Devanagari Headline height will be added manually after the visual hinting is applied for this glyph.

**YShift(28,26)** Shifts point 26, to a new position, relative to point 28’s new position on the grid, maintaining the same relative distance between the point 28 and point 26 as is in the original high resolution design of the outline. The shift command does not reference a cvt value and does not move the hinted point 26 to a full pixel grid line. Shift also does not default to a one pixel minimum used by the Link command. Using the Shift command will maintain a balanced visual weight, of this important Devanagari horizontal feature , across all variations.

With the Yshift Tool still selected, drag from point 26 to point 14 and from point 14 to point 23. The following code is generated.

**YShift(26,14)**
**YShift(14,23)**

 Shifts point 14, to a new position, relative to point 26’s new position maintaining the same relative distance between the point 26 and point 14, and point 23, as is in the original high resolution design of the outline. Point 14 and point 23 are now positioned correctly across all variations in the design space.

**A note on Hinting overlapping outlines**
 *Variable fonts are often designed with outlines that overlap. To ensure the hinted font renders correctly it is important to add hinting to points on the outline that overlap, so that these points maintain their correct position in the hinted outline. In this case, the shift command from point 26 to point 14 and 23, will ensure that point 14 and 23, maintain the correct position in the hinted outline, in the y-axis, between points 28 and 26. **Note** An alternative method to contol the correct positions for these overlapping points, is to interpolate points 14, 15, 23, 24, between points 28, and 26 in the y-axis YInterpolate(28,14,15,23,24,26). The overall effect is the same*

**Step 2: Devanagari Baseline Height Control** 

With the Yshift Tool still selected from the toolbar, position the ‘blue circle’, directly over point 21, click, and drag to point 22 and release. 

The following code is generated in the VTT Talk Window.

**Yanchor(21)**

Moves point 21 to the nearest gridline. The appropriate cvt for the Devanagari Baseline undershoot height will be added manually after the visual hinting is applied for this glyph.

**YShift(21,22)** Shifts point 22, to a new position, relative to point 21’s new position on the grid, maintaining the same relative distance between the point 21 and point 22 as is in the original high resolution design of the outline. 

**Step 3: Control position of mid section of glyph in Y-axis** 

Now that the Baseline and Headline Height have been established the middle section now needs to be interpolated to find its correct position. 

Choose the YInterpolate tool. Position the _‘blue circle’_, directly over point 28 and drag to point 21. You will see a line appear, which takes the form of a draggable _‘elastic band’._ No code is generated yet until a point is chosen to interpolate. Click anywhere on the line, and drag the curser to the point you want to interpolate, in this case point 0, and release. The following code is generated in the VTT Talk Window.

**YInterpolate(21,0,28)**

The middle section is now positioned correctly, between the base line and Headline height but one more step is needed. To maintain as much contrast as possible and to reduce blur, one side of the middle element, should to be aligned to the pixel grid. Right click on point 0, drag to the right to ‘round to grid’, and release. The YInterpolate code, will be replaced with the following code.

**YIPAnchor(21,0,28)**

Moves point 0, to full pixel grid, positioned relative to point 28 and point 21, which now has a new grid-fit position. This ensures high contrast on the bottom of the middle section of the GA glyph helping to minimise blur.

**Step 4: Control weight of mid section** 
Choose the YShift tool. Position the _‘blue circle’_, directly over point 0 and drag to point 7. The following code is generated in the VTT Talk Window.

**YShift(0,7)**
Shifts point 7, to a new position, relative to point 0’s new position on the grid, maintaining the same relative distance between the point 0 and point 7 as is in the original high resolution design of the outline. The shift command does not reference a cvt value and does not move the hinted point 7 to a full pixel grid line. Shift also does not default to a one pixel minimum used by the Link command. Using the Shift command will maintain a balanced visual weight, of horizontal features in particular, across all variations. 

**Step 5: Adding the Res command and Devanagari reference cvt's** 

_The Res addition to the command ResAnchor, for example, stands for Rendering Environment Specific, and ensures that the appropriate rounding happens, for various rendering environments. This saves adding additional Hinting commands if Hinting is required to work in a variety of rendering environments. _The Res command calls a Function, that is designed to also allow for more subtle rendering of features such as undershoots and overshoots_

Switch to the VTTtalk window** (`ctrl + 5`). Type Res before the YAnchor commands and add the reference to the correct height cvt's at the end of the YAnchor command. Compile VTT Talk, (`ctrl + r`) and save (`ctrl + s`). 

While in the VTTtalk Window, add the reference to the new Devanagari cvts that have been defined in the Control Value table. The final VTTtalk code, for the GA glyph, in the VTTtalk window will appear like this. The Res commands and cvts are highlighted here. After appending the Res commands to the YAnchors and adding the cvt’s, compile the VTTtalk window and save. 

/* Y direction */

**Res**YAnchor(21 **,170**)  /* baseline undershoot */

YShift(21,22)

**Res**YAnchor(28 **,167**) /* Main Flat Headline height */

YIPAnchor(21,0,28)

YShift(0,7)

YShift(28,26)

YShift(26,14)

YShift(14,23)

Smooth()

_The hinting for GA is now complete. Additional glyphs that share the same alignment can  now be hinted using the same overall stragety and referencing the same cvt values.Glyphs can be proofed in the main window, using the text string to see shape and spacing, in the size ramp to see the hinted results at a range of sizes, and in the Variation Window, to proof for all variations in the font._






