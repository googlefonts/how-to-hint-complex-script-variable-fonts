# A guide to hinting complex script Variable Fonts with Visual TrueType

by [Michael Duggan](https://twitter.com/mickduggan), in collaboration with Kalapi Gajjar-Bordawekar 

**Note:** This document is a companion piece to the longer [Hinting Latin TrueType Variable Fonts with Visual TrueType](https://github.com/googlefonts/how-to-hint-variable-fonts#introduction) 

*Please refer first to this comprehensive documentation for all of the details of the workflow, thorough descriptions of the hinting code, and how to use the VTT Tool to add hinting to Variable Fonts.*  

## Introduction

When thinking about adding hinting to any Variable font, it is a good idea to ask a few questions before beginning. How does hinting work in modern environments? What value can hinting add? Is hinting suitable for my font? The first two questions are answered in the longer VTT Variable font Hinting document, referenced above, which gives an overview of the current rendering technologies and the main benefits of modern hinting, with a focus on Variable Font Hinting. The third question can be answered by a series of tests and proofing in VTT. 

**Is hinting suitable for my font?**
Once you know more about what hinting is capable of, you can then ask a few questions about the font itself. Is the font intended for reading on-screen at smaller sizes or is it primarily a Display font, intended for use at larger sizes? If the latter, is hinting really needed? What benefits can I expect by adding hinting? How complex are the outline shapes? Many complex scripts fonts can benefit from hinting particularly at smaller sizes. However, for some scripts, such as Chinese, Japanese and Korean for example, the complexity of the outlines makes it impossible to apply hints that will benefit smaller sizes. Once there are enough pixels at larger sizes, hinting can help to sharpen common horizontal strokes and reduce blur. Every font should be evaluated to begin with to determine the most appropriate hinting strategy. 

We will look at these questions as we progress through this document, and will also look at the different approaches to hinting individual glyphs, and some of the limitations of Hinting for Variable fonts.

## VTT Autohinting for complex script Variable Fonts

Before beginning any new Hinting project, it is also important to understand the options and requirements for running the VTT Autohinter for complex script Variable fonts. The Visual TrueType tool has the following options for Autohinting.

**(1) Light Latin Autohinter:** Designed to work for Latin fonts, including Greek and Cyrillic. This option can also be used to add hinting to complex script fonts. **Note:** To run the VTT Light Latin Autohinter, for complex script fonts, VTT requires that the font must contain at least the Latin Ascii glyph set. If there is no Latin Ascii glyph set, the Light Latin Autohinter will not run, and will return an error message. (Example: Unicode 0x48 (H) is missing in this font). 

If your font contains a Latin and a complex script glyph set, the Latin portion of the font will be auto-hinted, with cvt’s generated for key Latin Heights. The Autohinter will add hinting code to the complex script glyph set, but will not generate cvt’s for any heights. Although the VTT Autohinter does not add cvt information for heights for complex script glyph sets, it is worthwhile running it, to begin any hinting project. In addition to adding basic hinting code, VTT also generates a full Font-Program and Pre-Program as well as code for any composites in the font. This saves a lot of time versus building this information from scratch. The basic hinting code that is added to the individual complex script glyphs can also be a good starting point to build from. We will look at this in more detail in the examples of hinting later in the Document.

**(2) EA Autohinter:** If a font does not contain a Latin subset, or you do not wish to add these glyphs you can run the VTT East Asian Autohinter. Using this option VTT will autohint a font without the requirement to add a Latin glyph set. If the hinting strategy used by the East Asian Autohinter is appropriate for you font, you can proceed from here using the code generated by the EA Autohinter. This will also include all of the necessary tables, Font-Program and Pre-Program. This Autohinter makes use of a lightweight hinting strategy that focuses on the horizontal strokes common in East Asian scripts. The strategy, takes advantage of Windows symmetric rendering modes and locks one side of horizontal strokes to the pixel grid while letting the top of other side float. This strategy balances edge contrast vs. blur and produces a good distribution of strokes with balanced counters. The Autohinting code output, should be reviewed and the font proofed carefully, to ensure this approach is suitable for your font. 

**(3) Control program only:** This option is similar to number 1 above, and has the same requirements for the inclusion of Latin glyph set. Using the control program only Autohinting option, is used when the intent is to add hinting to the font from scratch, via the graphical hinting interface or by writing the High Level VTT Talk by hand. The Control Program option will generate, a simple CVT Table, Font Program and will generate glyph program code for composite glyphs. Hinting code for the unique glyphs in the font will not be added. 

## Case Study: Hinting Noto Devanagari Serif Variable font

As an example of Hinting complex script Variable fonts, we will be looking at the workflow for autohinting and then fine tuning the hinting code, for key representative glyphs in the Noto Devanagari Serif Variable font. The workflow and concepts discussed for the Devanagari font, can be used and adapted for other complex script Variable fonts. Noto is a global font collection for writing in all modern and ancient languages. Noto Serif Devanagari is a modulated (“serif”) design for setting texts in the Indic Devanagari script. The Variable font supports multiple weights and widths. All of the processes and workflow can be followed and adapted for other complex script Variable fonts. A good way to begin, to evaluate the overall effects of hinting, is to run the VTT Autohinter, and review the output.

**Determining benefits of Hinting by running the Autohinter**

Sharpening of horizontal strokes at smaller screen sizes on lower resolution screens is one of the main effects of modern hinting. This sharpening significantly reduces blur along key horizontal strokes, producing much clearer text at smaller sizes on-screen. 

Running the VTT Autohinter and quickly reviewing the results will give you a good impression of the big picture of how hinting will help to render the font at small screen sizes particularly in relation to the key horizontals in the Devanagari font design. By evaluating the initial results produced by the Autohinter, you can determine the benefits of hinting and then build on refining the hinting code. 

<img width="100%" height="100%" src="Images/BlurvSharp.png">

**Left** Horizonal stroke un-hinted. After the un-hinted outline is scaled and rendered at a particular size, the result is very often a blurred line.
**Right** Horizonal stroke hinted. The Autohinter uses a strategy to move the outline to a high contrast grid boundary.

Following on from this basic idea, we can now see how this hinting effect, improves the rendering overall for many of the main Devanagari glyphs.

<img width="100%" height="100%" src="Images/DevanagariBlurSharp.png">

**Key Horizonal sharpening** Hinting results in sharpening of main Horizontal stokes, along the key Headline alignment zone, shown here using representative Devanagari glyphs at 9 and 12 point @96dpi


<img width="100%" height="100%" src="Images/WeightBlurSharp.png">

**Improvements across Variation space** One set of hinting code is applied to all weight and width variations in the Variable font, resulting in consistent sharpening of main Horizontal stokes for all weights. 

<img width="100%" height="100%" src="Images/Nohinthintcomparison.png">

**Devanagari text sample** 

Text Sample comparing hinted to un-hinted / Typeset at Axis-praxis.org / Universal Declaration of Human Rights / NotoSerifDevanagariVF_Demo.ttf, 15px, 11point@96dpi, Google Chrome (Version 99.0.4844.51) / Windows 11 / DirectWrite Rendering / Consistent sharpening and alignment along Headline of all Devanagari glyphs. Key details are kept clear on-screen at smaller text sizes


## Alignments and measurements

<img width="100%" height="100%" src="Images/HeightsDevanagari.png">

Key heights are determined by referencing some representative glyphs in the Noto Devanagari Variable font. The measurements taken from these glyphs, will be used to set up new cvt’s that be referenced in the hinting code.

Referencing ‘cvt’ values from hinting instructions in a set of glyphs that share similar measurements in the Devanagari font allows strict control over the regularity of these features. For the hinting approach described here, new cvt’s will be used to ensure key heights are kept consistent at any given point size. When adding hints, an ‘anchor’, _(such as is added by the Autohinter)_ on any point, will be rounded to the nearest grid line. However, a YAnchor, _for example,_ can refer to a ‘cvt’ value to specify a height or overshoot shared by other glyphs in the font. Instead of rounding to the nearest grid line, the anchored point will round to the grid line specified by the ‘cvt’ value. 

This is also useful for making global adjustments to heights, and proportions for a range of glyphs, by adjusting just one cvt. Global adjustments to proportions in complex script fonts, can help provide more space for Bolder weights, for example, helping to make the rendering much clearer on-screen.
 
## Adding new CVT’s for Devanagari 

Now that we have taken some measurements from the font outlines, we can build some new cvt’s for use in hinting the Devanagari. The illustration above shows four key measurements taken from representative glyphs. We can add further cvt’s when required, for any other alignment zones, that can be determined in the font.

To add the new cvt’s, open the Control program. At the end of the control program add the following cvt entries, starting with the next available ID number, in this case cvt number 167. _(Because this font contains a Latin Subset, the Autohinter has already generated cvt’s for the Latin font)_

Add four new cvt’s, for ‘Main Headline Height’, ‘Headline overshoot’, ‘Baseline’, and ‘Baseline undershoot’ using the measurements taken from the outlines. Compile and Save the Control Program. These new cvt’s are now available for use, and can be referenced in the VTTtalk Hinting code of individual glyphs.

/***** Devanagari Height cvt’s *****/
 
      167:   623 /* Main Flat Headline height */
  
ASM("SVTCA[Y]")

ASM("CALL[], 167, 89")
 
      169:     0 /* baseline */

ASM("SVTCA[Y]")

ASM("CALL[], 169, 89")

  RoundHeight

      168:    5 ~   167 @ 42 /* cap height overshoot */

      170:   -5 ~   169 @ 42 /* baseline undershoot */



## Hinting Devanagari letter GA (Unicode+0917)

Let’s begin by looking at how to add hinting to Devanagari letter GA. In this example we will delete the existing Autohinting code and add the hinting via the graphical user interface. The main height controls and cvt’s added to this glyph will set the direction for adding hinting and maintaining consistent height control for other Devanagari glyphs, that share the same headline and baseline heights. Many of the glyphs in the font share a common alignment. Please refer to the [demo font](https://github.com/googlefonts/how-to-hint-non-latin-variable-fonts/tree/main/VTTSourcesDemoFont) to review and study the hinting approach. The following glyphs have have been fine-tuned, and cvt’s added. 

**Hinted and fine tuned glyphs:** _(Gid 98 / Uni 0x0905), (Gid 102 / Uni 0x0909), (Gid 108 / Uni 0x090F), (Gid 149 / Uni 0x0917), (Gid 150 / Uni 0x0918), (Gid 152 / Uni 0x091A), (Gid 157 / Uni 0x091F), (Gid 159 / Uni 0x0921), (Gid 167 / Uni 0x092A), (Gid 172 / Uni 0x092F), (Gid 173 / Uni 0x0930), (Gid 174 / Uni 0x0932), (Gid 175 / Uni 0x0905)_

**Hinting strategy**

1. Control the y-max (Headline) and y-min of the glyph (Baseline / baseline undershoot) to be consistent with other glyphs that share the same alignment, using values in the Control Value Table as a reference. Minimise blur at the ‘Headline’.

2. Control the position of the middle element, in relation to the Baseline and Headline. 

![LatinAutohinter](Images/HintDevanagariOne.gif)

**Hinting the GA (Unicode 0917)**

**Step 1: Devanagari Headline Height Control** 

Choose the Yshift Tool from the Toolbar. Position the ‘blue circle’, directly over point 28, click, and drag to point 26 and release. 

The following code is generated in the VTT Talk Window.

**YAnchor (28)** Moves point 28 to the nearest gridline. The appropriate cvt for the Devanagari Headline height will be added manually after the visual hinting is applied for this glyph.

**YShift(28,26)** Shifts point 26, to a new position, relative to point 28’s new position on the grid, maintaining the same relative distance between the point 28 and point 26 as is in the original high resolution design of the outline. The shift command does not reference a cvt value and does not move the hinted point 26 to a full pixel grid line. Shift also does not default to a one pixel minimum used by the Link command. Using the Shift command will maintain a balanced visual weight, of this important Devanagari horizontal feature , across all variations.

With the Yshift Tool still selected, drag from point 26 to point 14 and from point 14 to point 23. The following code is generated.

**YShift(26,14)**
**YShift(14,23)**

 Shifts point 14, to a new position, relative to point 26’s new position maintaining the same relative distance between the point 26 and point 14, and point 23, as is in the original high resolution design of the outline. Point 14 and point 23 are now positioned correctly across all variations in the design space.

**A note on Hinting overlapping outlines**
 *Variable fonts are often designed with outlines that overlap. To ensure the hinted font renders correctly it is important to add hinting to points on the outline that overlap, so that these points maintain their correct position in the hinted outline. In this case, the shift command from point 26 to point 14 and 23, will ensure that point 14 and 23, maintain the correct position in the hinted outline, in the y-axis, between points 28 and 26. **Note** An alternative method to control the correct positions for these overlapping points, is to interpolate points 14, 15, 23, 24, between points 28, and 26 in the y-axis using YInterpolate(28,14,15,23,24,26). The overall effect is the same*

**Step 2: Devanagari Baseline Height Control** 

With the Yshift Tool still selected from the toolbar, position the ‘blue circle’, directly over point 21, click, and drag to point 22 and release. 

The following code is generated in the VTT Talk Window.

**Yanchor(21)**

Moves point 21 to the nearest gridline. The appropriate cvt for the Devanagari Baseline undershoot height will be added manually after the visual hinting is applied for this glyph.

**YShift(21,22)** Shifts point 22, to a new position, relative to point 21’s new position on the grid, maintaining the same relative distance between the point 21 and point 22 as is in the original high resolution design of the outline. 

**Step 3: Control position of mid-section of glyph in Y-axis** 

Now that the Baseline and Headline Height have been established the middle section now needs to be interpolated to find its correct position. 

Choose the YInterpolate tool. Position the _‘blue circle’_, directly over point 28 and drag to point 21. You will see a line appear, which takes the form of a draggable _‘elastic band’._ No code is generated yet until a point is chosen to interpolate. Click anywhere on the line, and drag the curser to the point you want to interpolate, in this case point 0, and release. The following code is generated in the VTT Talk Window.

**YInterpolate(21,0,28)**

The middle section is now positioned correctly, between the base line and Headline height but one more step is needed. To maintain as much contrast as possible and to reduce blur, one side of the middle element, should to be aligned to the pixel grid. Right click on point 0, drag to the right to ‘round to grid’, and release. The YInterpolate code, will be replaced with the following code.

**YIPAnchor(21,0,28)**

Moves point 0, to full pixel grid, positioned relative to point 28 and point 21, which now has a new grid-fit position. This ensures high contrast on the bottom of the middle section of the GA glyph helping to minimise blur.

**Step 4: Control weight of mid-section** 
Choose the YShift tool. Position the _‘blue circle’_, directly over point 0 and drag to point 7. The following code is generated in the VTT Talk Window.

**YShift(0,7)**
Shifts point 7, to a new position, relative to point 0’s new position on the grid, maintaining the same relative distance between the point 0 and point 7 as is in the original high resolution design of the outline. The shift command does not reference a cvt value and does not move the hinted point 7 to a full pixel grid line. Shift also does not default to a one pixel minimum used by the Link command. Using the Shift command will maintain a balanced visual weight, of horizontal features in particular, across all variations. 

**Step 5: Adding the Res command and Devanagari reference cvt’s** 

_The Res addition to the command ResAnchor, for example, stands for Rendering Environment Specific, and ensures that the appropriate rounding happens, for various rendering environments. This saves adding additional Hinting commands if Hinting is required to work in a variety of rendering environments. _The Res command calls a Function, that is designed to also allow for more subtle rendering of features such as undershoots and overshoots_

Switch to the VTTtalk window** (`ctrl + 5`). Type Res before the YAnchor commands and add the reference to the correct height cvt’s at the end of the YAnchor command. Compile VTT Talk, (`ctrl + r`) and save (`ctrl + s`). 

While in the VTTtalk Window, add the reference to the new Devanagari cvt’s that have been defined in the Control Value table. The final VTTtalk code, for the GA glyph, in the VTTtalk window will appear like this. The Res commands and cvt’s are highlighted here. After appending the Res commands to the YAnchors and adding the cvt’s, compile the VTTtalk window and save. 

/* Y direction */

**Res**YAnchor(21 **,170**)  /* baseline undershoot */

YShift(21,22)

**Res**YAnchor(28 **,167**) /* Main Flat Headline height */

YIPAnchor(21,0,28)

YShift(0,7)

YShift(28,26)

YShift(26,14)

YShift(14,23)

Smooth()

_The hinting for GA is now complete. Additional glyphs that share the same alignment can  now be hinted using the same overall strategy and referencing the same cvt values. Glyphs can be proofed in the main window, using the text string to see shape and spacing, in the size ramp to see the hinted results at a range of sizes, and in the Variation Window, to proof for all variations in the font._

**Pro Tips** 

**Notes on adding new cvt’s**

When adding new hinting code from scratch, or when editing the output from the Autohinter, choose the option under `Display > Options > VTT Attributes` > **Show CVT numbers.** 

When new cvt’s are added and the code is compiled in the VTTtalk code, _(as shown in the animation above)_ the cvt numbers will be shown graphically in the main window. As you progress through hinting the glyph set, showing cvt numbers allows for easier visual proofing of the hinted glyphs in the Main Window, for example to quickly determine whether the correct cvt’s are used for heights. 

**Notes on Character Group information and adding new cvt’s**

Each glyph in a font has Character group information associated with it. The character group tells VTT which group of values to use from the Control Value Table. When hinting complex fonts, such as Devanagari, the Character group information is usually listed as ‘Other’. _(The Character group information is listed at the top of the Main Window, after the Unicode Value for the glyph. The categories are UpperCase, LowerCase, Figure, Reserved 1,2 & 3, Anygroup, Other)._ 

The VTT Autohinter generates cvt’s for the Other group. When hinting a glyph from scratch using the Visual Hinting tools, VTT uses the character group information to pick cvt’s YAnchors for example. When the character group is set to ‘Other’, VTT will look for the cvt’s defined as ‘Other’ in the cvt table, and will add these automatically. To avoid this happening, you can change the character group information for the glyph you are hinting to ‘Anygroup’.

**To change the character group information of the current glyph**

`Edit > Change char group` or press ctrl + U, until ‘Anygroup’ is listed, then choose File and save.  

When the Character Group info is set to ‘Anygroup’, and saved, adding the YAnchor Hinting commands for the Devanagari heights, via the graphical hinting tools, will generate a Yanchor with no cvt associated with it. You can then manually add references to the correct Devanagari cvt’s, compile and save. The alternative to this approach is to let VTT choose a cvt. You must then remember to change that cvt reference to use the correct custom script specific cvt you have created in the cvt table, such as the ones we created above for the Devanagari font.


## Hinting Devanagari letter DdA (Unicode+0921)

Adding Hinting for a complex Devanagari glyph. 

**Hinting strategy**

1. Control the y-max (Headline) and y-min to be consistent with other glyphs that share the same alignment, using values in the Control Value Table as a reference. Minimise blur at the ‘Headline’, and y-min of the glyph

2. Control the position of the middle elements, in relation to the y-min and Headline. The main advantages of adding hinting to this glyph will be to ensure that the top and bottom of the glyph are moved to a sharp alignment. Because we have to use only one set of hints for all of the variation weights, from Light to Black, control of the middle is done by interpolation only. This will ensure that the overall shape of the glyph is correctly maintained. 

![LatinAutohinter](Images/HintDevanagariTwo.gif)


## Adjusting global proportions

At small screen sizes there are a limited number of pixels available to describe and render more complex glyph shapes. Adjusting the overall height of the Devanagari glyphs, can help to make the shapes clearer, particularly in the heavier weights. 

![LatinAutohinter](Images/HintDevanagariThree.gif)

In this example the Main Headline Devanagari height ‘cvt’ 167, stores a measurement of 623 font units, which is the measured outline distance of the square Headline Height. 

At 12 point at 72dpi / 9 point at 96dpi, this value is scaled, and rounds to the nearest pixel grid, which results in a Baseline to Headline Height of 7 pixels () 

At 15 point at 72dpi / 11 point at 96dpi, this value is scaled, and rounds to the nearest pixel grid, which results in a Baseline to Headline Height of 9 pixels ()

At 20 point at 72dpi / 15 point at 96dpi, this value is scaled, and rounds to the nearest pixel grid, which results in a Baseline to Headline Height of 7 pixels ()
 
To change this height globally, a ‘Delta’ command is used to raise the Headline Height for all glyphs that reference the ‘cvt’ for either square or round Headline height. This Delta command raises the Headline Height by one pixel for all of the instances in the font. 

**Note:** When adjusting one height, other heights should also be reviewed, and adjusted if necessary, to ensure the correct proportion is maintained, between heights.
 
**Globally adjust height in the ‘cvt’ table:**

Open the CVT Table (`ctrl + 4`) and refer to the ‘cvt’ for Headline Height, ‘cvt’ number 167. Directly after the ‘cvt’ type the following, Delta(1@12;15;20) and compile, ctrl ( r ) and save.
 
**CVT Entry for Square Devanagari Headline Height**
167:  1462 /* Square Headline Height */
 
Delta(1@12;15;20) /* Raise Headline Height globally by 1 pixel */
 
**Note:** In Variable fonts a global Delta command can only be used, if the cvt does not vary across the Variation Space. For example, a Bolder weight variation may have a larger measured outline height. This height is edited in the ‘cvar’ _(cvt variation table)_ to reflect this difference. Because of the difference in height, the bolder weight cvt, can round differently and the ‘Delta’ to change the height for the Bold may not be required.

## Hinting components

![LatinAutohinter](Images/HintDevanagariFour.gif)
